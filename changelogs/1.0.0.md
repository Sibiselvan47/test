# [1.0.0] - Soon (TM)

## What's new in Tartiflette 1.0

### Parsing

* both SDL and query parsing does now focus only on the parsing and returns a `DocumentNode` instance
* the grammar used by the lark parser in order to parse the SDL is now fully feature compliant with the [June 2018 GraphQL specification](https://graphql.github.io/graphql-spec/June2018/)
* the validation part of the query has been dissociate from the parsing itself and are now cached for each query for performance improvement
* in addition to the cache on top of the parsing and validation process of a query, we now use the `graphql_ast_to_json` feature of the `libgraphqlparser` to gain in performance

### Execution

#### Miscellaneous

* the whole execution process now fit the [June 2018 GraphQL specification](https://graphql.github.io/graphql-spec/June2018/)
* input fields are now properly calling the `on_post_input_coercion` directive hook instead of `on_argument_execution` one
* arguments coercions are now fully working and directives on arguments directives are now properly coerced:
    ```graphql
    directive @maxValue(limit: Int!) on ARGUMENT_DEFINITION

    directive @truncate(
      limit: Int! @maxValue(limit: 25) # Previously, `@maxValue` was never triggered
    ) on FIELD_DEFINITION | FIELD

    type Query {
      hello(name: String!): String! @truncate(limit: 10)
    }
    ```
* a new `TypeResolver` decorator is available to resolve easily types of abstract types ([more detail here](http://tartiflette.io))
* for performance, most of the execution algorithm are pre-computed at engine initialization especially things related to input and output coercions
* a new internal class `GraphQLInputField` has been implemented to make the distinction with `GraphQLArgument`
* in some cases, `@if` and `@skip` directives could have an unexpected behaviour, this is no more the case and has been fixed
* variables are now coerced only once before executing the query. This allow us to execute the query only if variables
values are valid. This has also an impact on directives execution. Since variables are coerced once, directives that could
be applied on scalar or input fields of a variable will be also triggered only once
* we made a strong distinction between `null` values and `undefined `values to avoid forwarding `null` for `undefined` values

#### Introspection

An important point for us to release the Tartiflette 1.0 was to make the introspection query feature compliant with the [June 2018 GraphQL specification](https://graphql.github.io/graphql-spec/June2018/).
In addition, we had some performance issues on the introspection query on our previous versions that we wanted to address.

From Tartifllette v1:
* the introspection query is now fully feature compliant with the [June 2018 GraphQL specification](https://graphql.github.io/graphql-spec/June2018/)
* the built-in introspection SDL has been fixed on the `__Type.kind` field which is now `__TypeKind!` instead of `__TypeKind`
* descriptions has been added on the built-in introspection SDL as well as on the other built-in objects (directives, scalars...)
* the optional argument `includeDeprecated` available on both `__Type.enumValues` and `__Type.fields` does now work properly depending on the provided value
* to address the performance issue, we have baked as much as possible all introspection attributes at engine initialization time to be fastly accessible at execution time

### Errors

We made an important work on the error management. Error messages are now more
explicit and relevant. In addition, in previous versions `path` and `locations`
keys in errors could be wrong or `null`. Now, whenever we have the information,
those values are set and available for a better error management client side.

## Backwards incompatible changes in 1.0

### Miscellaneous

* the engine [`error_coercer`](https://tartiflette.io/docs/api/error-handling#advanced-add-a-global-error-coercer) has to be an asynchronus callable:
    ```python
    # Old
    def my_error_coercer(
        exception: Exception, error: Dict[str, Any]
    ) -> Dict[str, Any]:
        if isinstance(exception, CustomException):
            logging.error("Unable to reach the Storage host.")
            error["extensions"]["type"] = exception.type
        return error


    # New
    async def my_error_coercer(
        exception: Exception, error: Dict[str, Any]
    ) -> Dict[str, Any]:
        if isinstance(exception, CustomException):
            logging.error("Unable to reach the Storage host.")
            error["extensions"]["type"] = exception.type
        return error
    ```
* the shape of the `info` parameter available on resolvers for example has changed ([more detail here](#TODO))
* the `@Subscription` without dedicated `@Resolver` doesn't wraps the message into the field name anymore. For example:
    ```python
    """
    # SDL
    enum CookingStatus {
      COOKING
      COOKED
    }

    type CookingTimer {
      remainingTime: Int!
      status: CookingStatus!
    }

    type Subscription {
      launchAndWaitCookingTimer(id: Int!): CookingTimer
    }
    """


    # Old
    @Subscription("Subscription.launchAndWaitCookingTimer")
    async def subscribe_subscription_launch_and_wait_cooking_timer(
        parent, args, ctx, info
    ) -> Dict[str, Any]:
        yield {"remainingTime": 0, "status": "COOKED"}


    # New
    @Subscription("Subscription.launchAndWaitCookingTimer")
    async def subscribe_subscription_launch_and_wait_cooking_timer(
        parent, args, ctx, info
    ) -> Dict[str, Any]:
        yield {
            "launchAndWaitCookingTimer": {"remainingTime": 0, "status": "COOKED"}
        }
    ```
    On previous versions, subscription had a specific default resolver which would have automatically added the result of the messages coming from the subscription in a dictionary such as: `{"launchAndWaitCookingTimer": message}`. It was too magic and could lead to errors. It is now up to you to returns a well formatted message or to implement a dedicated `@Resolver` for your subscription field.
* arguments coercion has been improved and we now make a strong distinction between `null` values and `undefined` values which could have an impact on your resolvers:
    ```python
    """
    # SDL
    type News {
      id: Int!
      title: String!
      resume: String
      content: String!
    }

    input AddNewsInput {
      title: String!
      resume: String
      content: String!
    }

    type Mutation {
      addNews(input: AddNewsInput!): News!
    }

    # Query
    mutation {
      addNews(input: {title: "Title", content: "Content"}) {
        id
        title
        resume
        content
      }
    }
    """


    @Resolver("Mutation.addNews")
    async def resolve_mutation_add_news(parent, args, ctx, info):
        # `args` value will be:
        # Old versions:
        # {"input": {"title": "Title", "resume": None, "content": "Content"}}
        # New version:
        # `{"input": {"title": "Title", "content": "Content"}}`
        return {"id": 1, "title": "Title", "content": "Content"}
    ```

### Directives

Some directives hook signatures has changed:

* `on_argument_execution` ([more detail on the signature here](#TODO)):
    ```python
    # Old
    class ArgumentExecutionDirective:
        async def on_argument_execution(
            self,
            directive_args: Dict[str, Any],
            next_directive: Callable,
            argument_definition: "GraphQLArgument",
            args: Dict[str, Any],
            ctx: Optional[Any],
            info: "Info",
        ) -> Any:
            pass

    # New
    class ArgumentExecutionDirective:
        async def on_argument_execution(
            self,
            directive_args: Dict[str, Any],
            next_directive: Callable,
            parent_node: Union["FieldNode", "DirectiveNode"],
            argument_node: "ArgumentNode",
            value: Any,
            ctx: Optional[Any],
        ):
            pass
    ```

* `on_post_input_coercion` ([more detail on the signature here](#TODO)):
    ```python
    # Old
    class PostInputCoercionDirective:
        async def on_post_input_coercion(
            self,
            directive_args: Dict[str, Any],
            next_directive: Callable,
            value: Any,
            argument_definition: "GraphQLArgument",
            ctx: Optional[Any],
            info: "Info",
        ) -> Any:
            pass

    # New
    class PostInputCoercionDirective:
        async def on_post_input_coercion(
            self,
            directive_args: Dict[str, Any],
            next_directive: Callable,
            value: Any,
            ctx: Optional[Any],
        ) -> Any:
            pass
    ```

* `on_pre_output_coercion` ([more detail on the signature here](#TODO)):
    ```python
    # Old
    class PreOutputCoercionDirective:
        async def on_pre_output_coercion(
            self,
            directive_args: Dict[str, Any],
            next_directive: Callable,
            value: Any,
            field_definition: "GraphQLField",
            ctx: Optional[Any],
            info: "ResolveInfo",
        ) -> Any:
            pass

    # New
    class PreOutputCoercionDirective:
        async def on_pre_output_coercion(
            self,
            directive_args: Dict[str, Any],
            next_directive: Callable,
            value: Any,
            ctx: Optional[Any],
            info: "ResolveInfo",
        ) -> Any:
            pass
    ```

### Scalars

In previous version, when writing [custom scalars](https://tartiflette.io/docs/api/scalar)
you had to implements two methods:
* `coerce_input(self, value: Any) -> Any`
* `coerce_output(self, value: Any) -> Any`

From version 1, you will have to implements a third method
`parse_literal(self, ast: "Node") -> Union[Any, "UNDEFINED_VALUE"]`.

In the version 1, we had to split the input values in two types, the input values
and the literal values. Input values are values coming from the variables and will
be coerced by the `coerce_input` method. Literal values come from the query or the
SDL itself, they correspond to the "hard code" values which will be coerced by
the `parse_literal` method.

More information on writing a custom scalar [here](#TODO).
